!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Meson	B,build	/build targets/
!_TAG_KIND_DESCRIPTION!Meson	P,project	/projects/
!_TAG_KIND_DESCRIPTION!Meson	S,subdir	/subdirs/
!_TAG_KIND_DESCRIPTION!Meson	V,variable	/variables/
!_TAG_KIND_DESCRIPTION!Meson	b,benchmark	/benchmark targets/
!_TAG_KIND_DESCRIPTION!Meson	c,custom	/custom targets/
!_TAG_KIND_DESCRIPTION!Meson	m,module	/modules/
!_TAG_KIND_DESCRIPTION!Meson	r,run	/run targets/
!_TAG_KIND_DESCRIPTION!Meson	t,test	/tests/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PARSER_VERSION!Meson	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/nitro/Projects/nipi-test/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/v6.1.0/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Meson!module	imported	/imported/
Point	objects.hpp	/^struct Point{$/;"	s
Polygon	objects.hpp	/^	Polygon( Point pos, int n,double r=1){$/;"	f	class:Polygon
Polygon	objects.hpp	/^class Polygon : public Polyline {$/;"	c
Polyline	objects.hpp	/^class Polyline {$/;"	c
Quad	quad.hpp	/^struct Quad{$/;"	s
QuadTree	quad.cpp	/^QuadTree::QuadTree(){$/;"	f	class:QuadTree
QuadTree	quad.hpp	/^class QuadTree {$/;"	c
Rect	quad.hpp	/^struct Rect {$/;"	s
X	objects.hpp	/^	double X;$/;"	m	struct:Point	typeref:typename:double
Y	objects.hpp	/^	double Y;$/;"	m	struct:Point	typeref:typename:double
_data	main.cpp	/^std::vector<Polyline> _data;$/;"	v	typeref:typename:std::vector<Polyline>
_points	objects.hpp	/^    std::vector<Point> _points;$/;"	m	class:Polyline	typeref:typename:std::vector<Point>
ax	quad.hpp	/^	double ax;$/;"	m	struct:Rect	typeref:typename:double
ay	quad.hpp	/^	double ay;$/;"	m	struct:Rect	typeref:typename:double
bnipi-test	meson.build	/^project('bnipi-test','cpp')$/;"	P
bounding_box	quad.hpp	/^	Rect bounding_box;$/;"	m	struct:Quad	typeref:typename:Rect
bx	quad.hpp	/^	double bx;$/;"	m	struct:Rect	typeref:typename:double
by	quad.hpp	/^	double by;$/;"	m	struct:Rect	typeref:typename:double
contains	quad.cpp	/^bool Rect::contains(Polyline &line){$/;"	f	class:Rect	typeref:typename:bool
contains	quad.cpp	/^bool Rect::contains(Rect &other){$/;"	f	class:Rect	typeref:typename:bool
find_objects	main.cpp	/^std::vector<Polyline> find_objects(std::pair<double, double> aLeftTop, std::pair<double, double>/;"	f	typeref:typename:std::vector<Polyline>
generate_polygons	main.cpp	/^void generate_polygons(){$/;"	f	typeref:typename:void
getAABB	quad.cpp	/^Rect Rect::getAABB(Polyline &poly){$/;"	f	class:Rect	typeref:typename:Rect
get_inside_box	quad.cpp	/^std::vector<Polyline *>  QuadTree::get_inside_box(Rect &rect){$/;"	f	class:QuadTree	typeref:typename:std::vector<Polyline * >
get_node_bb	quad.cpp	/^Rect Quad::get_node_bb(int i){$/;"	f	class:Quad	typeref:typename:Rect
get_points	objects.hpp	/^    const std::vector<Point>& get_points()$/;"	f	class:Polyline	typeref:typename:const std::vector<Point> &
insert	quad.cpp	/^void Quad::insert(Polyline *poly,Rect bb){$/;"	f	class:Quad	typeref:typename:void
insert	quad.cpp	/^void QuadTree::insert(Polyline *poly){$/;"	f	class:QuadTree	typeref:typename:void
main	main.cpp	/^int main(){$/;"	f	typeref:typename:int
main	meson.build	/^executable('main',src)$/;"	B
nodes	quad.hpp	/^	Quad *nodes[4]={0};$/;"	m	struct:Quad	typeref:typename:Quad * [4]
overlaps	quad.cpp	/^bool Rect::overlaps(Polyline &line){$/;"	f	class:Rect	typeref:typename:bool
overlaps	quad.cpp	/^bool Rect::overlaps(Rect &other){$/;"	f	class:Rect	typeref:typename:bool
polylines	quad.hpp	/^	std::vector<Polyline *> polylines;$/;"	m	struct:Quad	typeref:typename:std::vector<Polyline * >
root	quad.hpp	/^	Quad root;$/;"	m	class:QuadTree	typeref:typename:Quad
search	quad.cpp	/^void Quad::search(std::vector<Polyline *> &result,Rect screen){$/;"	f	class:Quad	typeref:typename:void
set_points	objects.hpp	/^    void set_points(const std::vector<Point> aPoints)$/;"	f	class:Polyline	typeref:typename:void
src	meson.build	/^src=[$/;"	V
tree	main.cpp	/^QuadTree tree;$/;"	v	typeref:typename:QuadTree
~QuadTree	quad.cpp	/^QuadTree::~QuadTree(){$/;"	f	class:QuadTree
